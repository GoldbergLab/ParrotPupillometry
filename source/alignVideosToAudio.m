function alignVideosToAudio(sync_struct, aligned_folder, options)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% alignVideosToAudio: Align webcam, naneye, and DAQ audio to each other
% usage: alignVideosToAudio(sync_struct, aligned_folder, options)
%
% where,
%    sync_struct is a struct containing synchronization information for the
%       three data streams, generated by getPupillometryDataAlignment
%    aligned_folder is the path to a folder where the aligned data files
%       should be written
%    Name/Value arguments can include:
%       ClickChannel - Audio channel # containing the sync clicks.
%       VideoClicks - Whether or not to include sync click audio channel
%           in the saved video files. The click channel will be included
%           in the saved audio files regardless. Default is true
%       PulsesPerFile - how many sync pulse periods each file should 
%           include. Default is 1.
%
% This function takes the synchronization information extracted by
%   getPupillometryDataAlignment, and executes the alignment of the data
%   streams by recutting all each data stream into new files that start on
%   sync pulse onsets.
%
% See also: getPupillometryDataAlignment
%
% Version: 1.0
% Author:  Brian Kardon
% Email:   bmk27=cornell*org, brian*kardon=google*com
% Real_email = regexprep(Email,{'=','*'},{'@','.'})
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
arguments
    sync_struct struct
    aligned_folder
    options.ClickChannel = 1
    options.VideoClicks = true
    options.PulsesPerFile = 2;
    options.WriteSourceInfo = true
end

% Record sync_struct
save(fullfile(aligned_folder, 'sync_struct.mat'), 'sync_struct');

% # of sync pulse periods that should be included in each output file
pulse_periods_per_file = options.PulsesPerFile;

% Initialize file cache
[~, file_cache] = cacheLoadFile();

% Define utility functions
audio_loader = @audioread;
audio_data_slicer = @(data, start, stop)data(start:stop, :);
audio_data_sizer = @(data)size(data, 1);
audio_data_combiner = @(data1, data2)[data1; data2];
video_loader = @(path)fastVideoReader(path);
video_data_slicer = @(data, start, stop)data(:, :, :, start:stop);
video_data_sizer = @(data)size(data, 4);
video_data_combiner = @(data1, data2)cat(4, data1, data2);

% Output loop:
% Loop over the pulses, skipping by # of pulse periods per file
for pulse_idx = 1:pulse_periods_per_file:length(sync_struct)
    fprintf('PULSE IDX: %d of %d\n', pulse_idx, length(sync_struct))
    end_pulse_idx = pulse_idx + pulse_periods_per_file;
    if end_pulse_idx > length(sync_struct)
        % Just drop the final data files if theyt don't have the full # of 
        % pulses in them, not worth the hassle to make a partial end file
        break;
    end

    % Get the rows of the sync struct relevant to these sync pulses
    sync_struct_segment = sync_struct(pulse_idx:end_pulse_idx);
    audio_data = [];
    naneye_data = [];
    webcam_data = [];

    audio_index_info = [];
    naneye_index_info = [];
    webcam_index_info = [];

    audio_filled = [];
    naneye_filled = [];
    webcam_filled = [];

    % Loop over pulse periods to include in this output file
    for idx = 1:pulse_periods_per_file
        % Extract information from this pulse and the next one, because files
        %   likely span multiple pulse periods
        % Audio file paths:
        this_path = sync_struct_segment(idx).audio_file;
        next_path = sync_struct_segment(idx+1).audio_file;
        % Click onsets:
        this_onset = sync_struct_segment(idx).click_onset;
        next_onset = sync_struct_segment(idx+1).click_onset;
        % Drop info
        this_drop_info = [];
        next_drop_info = [];
        % Gather data for this pulse period
        [audio_data_piece, audio_index_info_piece, audio_filled_piece] = ...
            collect_sync_pulse_period_data(this_path, next_path, this_drop_info, next_drop_info, this_onset, next_onset, file_cache, audio_loader, audio_data_slicer, audio_data_sizer, audio_data_combiner, [], 'DataType', 'audio', 'MaxCacheSize', 9);

        % Naneye file paths
        this_path = sync_struct_segment(idx).naneye_file;
        next_path = sync_struct_segment(idx+1).naneye_file;
        % Flash onsets
        this_onset = sync_struct_segment(idx).naneye_flash_onset;
        next_onset = sync_struct_segment(idx+1).naneye_flash_onset;
        % Drop info
        this_drop_info = sync_struct_segment(idx).naneye_drop_info;
        next_drop_info = sync_struct_segment(idx+1).naneye_drop_info;
        % Gather data for this pulse period
        [naneye_data_piece, naneye_index_info_piece, naneye_filled_piece] = ...
            collect_sync_pulse_period_data(this_path, next_path, this_drop_info, next_drop_info, this_onset, next_onset, file_cache, video_loader, video_data_slicer, video_data_sizer, video_data_combiner, @fillInDroppedVideoFrames, 'DataType', 'video', 'MaxCacheSize', 9);

        % Webcam file paths
        this_path = sync_struct_segment(idx).webcam_file;
        next_path = sync_struct_segment(idx+1).webcam_file;
        % Flash onsets
        this_onset = sync_struct_segment(idx).webcam_flash_onset;
        next_onset = sync_struct_segment(idx+1).webcam_flash_onset;
        % Drop info
        this_drop_info = [];
        next_drop_info = [];
        % Gather data for this pulse period
        [webcam_data_piece, webcam_index_info_piece, webcam_filled_piece] = ...
            collect_sync_pulse_period_data(this_path, next_path, this_drop_info, next_drop_info, this_onset, next_onset, file_cache, video_loader, video_data_slicer, video_data_sizer, video_data_combiner, [], 'DataType', 'video', 'MaxCacheSize', 9);

        % Combine this new pulse data with data from prior pulses, if any
        audio_data = audio_data_combiner(audio_data, audio_data_piece);
        naneye_data = video_data_combiner(naneye_data, naneye_data_piece);
        webcam_data = video_data_combiner(webcam_data, webcam_data_piece);

        % Combine this new index data with data from prior pulses, if any
        audio_index_info = [audio_index_info, audio_index_info_piece]; %#ok<*AGROW>
        naneye_index_info = [naneye_index_info, naneye_index_info_piece];
        webcam_index_info = [webcam_index_info, webcam_index_info_piece];

        audio_filled = [audio_filled, audio_filled_piece];
        naneye_filled = [naneye_filled, naneye_filled_piece];
        webcam_filled = [webcam_filled, webcam_filled_piece];
    end

    naneye_data = reorientNaneyeVideo(naneye_data);

    mean_audio_fs = mean([sync_struct_segment.audio_fs]);
    mean_naneye_fs = mean([sync_struct_segment.naneye_fs]);
    mean_webcam_fs = mean([sync_struct_segment.webcam_fs]);

    pulse_tag = sprintf('pulse%04d_', pulse_idx);

    [~, name, ext] = fileparts(sync_struct_segment(1).audio_file);
    audio_output_path = fullfile(aligned_folder, [pulse_tag, name, ext]);
    audiowrite(audio_output_path, audio_data, mean_audio_fs);
    if options.WriteSourceInfo; writeSourceInfo(audio_output_path, audio_index_info, audio_filled); end

    if ~options.VideoClicks
        % Exclude click channel from audio
        audio_channel_list = 1:size(audio_data, 2);
        if sum(audio_channel_list == options.ClickChannel) ~= 1
            error('Something went wrong excluding the click channel - got %d as click channel, but found %d audio channels.', options.ClickChannel, size(audio_data, 2));
        end
        audio_channel_list = audio_channel_list(audio_channel_list ~= options.ClickChannel);
        audio_data = audio_data(:, audio_channel_list);
    end

    [~, name, ext] = fileparts(sync_struct_segment(1).naneye_file);
    naneye_output_path = fullfile(aligned_folder, [pulse_tag, name, ext]);
    fastVideoWriter(naneye_output_path, naneye_data, '-c:v', 'h264', '-crf', '20', 'FrameRate', mean_naneye_fs, 'AudioData', audio_data);
    % saveVideoData(naneye_data, naneye_output_path, 'Motion JPEG AVI', mean_naneye_fs);
    if options.WriteSourceInfo; writeSourceInfo(naneye_output_path, naneye_index_info, naneye_filled); end

    [~, name, ext] = fileparts(sync_struct_segment(1).webcam_file);
    webcam_output_path = fullfile(aligned_folder, [pulse_tag, name, ext]);
    fastVideoWriter(webcam_output_path, webcam_data, '-c:v', 'h264', '-crf', '20', 'FrameRate', mean_webcam_fs, 'AudioData', audio_data);
    % saveVideoData(webcam_data, webcam_output_path, 'Motion JPEG AVI', mean_webcam_fs);
    if options.WriteSourceInfo; writeSourceInfo(webcam_output_path, webcam_index_info, webcam_filled); end

end

function newVideoData = reorientNaneyeVideo(videoData)
w = size(videoData, 2);
h = size(videoData, 1);
n = size(videoData, 4);

newW = 2 * w;
newH = h / 2;

newVideoData = zeros([newH, newW, 3, n], class(videoData));
newVideoData(:, 1:w, :, :) = videoData(1:newH, :, :, :);
newVideoData(:, w+1:end, :, :) = videoData(newH+1:end, :, :, :);


function writeSourceInfo(data_path, index_info, filled)

[folder, name, ~] = fileparts(data_path);

info_path = fullfile(folder, [name '_info.json']);

% Find indices of filled samples/frames
filled_samples = find(filled(:));

source_info.sources = index_info;
source_info.filled_samples = filled_samples;

% Encode as pretty JSON array
json_str = jsonencode(source_info, 'PrettyPrint', true);

% Write to file
fid = fopen(info_path, 'w');
if fid == -1
    error('Could not open %s for writing.', info_path);
end
fwrite(fid, json_str, 'char');
fclose(fid);
