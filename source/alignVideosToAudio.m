function alignVideosToAudio(sync_struct, aligned_folder, options)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% alignVideosToAudio: Align webcam, naneye, and DAQ audio to each other
% usage: alignVideosToAudio(sync_struct, aligned_folder, options)
%
% where,
%    sync_struct is a struct containing synchronization information for the
%       three data streams, generated by getPupillometryDataAlignment
%    aligned_folder is the path to a folder where the aligned data files
%       should be written
%    Name/Value arguments can include:
%       AudioChannel - not used yet
%       PulsesPerFile - how many sync pulse periods each file should 
%           include. Default is 1.
%
% This function takes the synchronization information extracted by
%   getPupillometryDataAlignment, and executes the alignment of the data
%   streams by recutting all each data stream into new files that start on
%   sync pulse onsets.
%
% See also: getPupillometryDataAlignment
%
% Version: 1.0
% Author:  Brian Kardon
% Email:   bmk27=cornell*org, brian*kardon=google*com
% Real_email = regexprep(Email,{'=','*'},{'@','.'})
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
arguments
    sync_struct struct
    aligned_folder
    options.AudioChannel = 1
    options.PulsesPerFile = 2;
    options.WriteSourceInfo = true
end

% # of sync pulse periods that should be included in each output file
pulse_periods_per_file = options.PulsesPerFile;

% Initialize file cache
[~, file_cache] = cacheLoadFile();

% Define utility functions
audio_loader = @audioread;
audio_data_slicer = @(data, start, stop)data(start:stop, :);
audio_data_sizer = @(data)size(data, 1);
audio_data_combiner = @(data1, data2)[data1; data2];
video_loader = @(path)fastVideoReader(path);
video_data_slicer = @(data, start, stop)data(:, :, :, start:stop);
video_data_sizer = @(data)size(data, 4);
video_data_combiner = @(data1, data2)cat(4, data1, data2);

% Output loop:
% Loop over the pulses, skipping by # of pulse periods per file
for pulse_idx = 1:pulse_periods_per_file:length(sync_struct)
    fprintf('PULSE IDX: %d of %d\n', pulse_idx, length(sync_struct))
    end_pulse_idx = pulse_idx + pulse_periods_per_file;
    if end_pulse_idx > length(sync_struct)
        % Just drop the final data files if theyt don't have the full # of 
        % pulses in them, not worth the hassle to make a partial end file
        break;
    end

    % Get the rows of the sync struct relevant to these sync pulses
    sync_struct_segment = sync_struct(pulse_idx:end_pulse_idx);
    audio_data = [];
    naneye_data = [];
    webcam_data = [];

    audio_index_info = [];
    naneye_index_info = [];
    webcam_index_info = [];

    audio_filled = [];
    naneye_filled = [];
    webcam_filled = [];

    % Loop over pulse periods to include in this output file
    for idx = 1:pulse_periods_per_file
        % Extract information from this pulse and the next one, because files
        %   likely span multiple pulse periods
        % Audio file paths:
        this_path = sync_struct_segment(idx).audio_file;
        next_path = sync_struct_segment(idx+1).audio_file;
        % Click onsets:
        this_onset = sync_struct_segment(idx).click_onset;
        next_onset = sync_struct_segment(idx+1).click_onset;
        % Drop info
        this_drop_info = [];
        next_drop_info = [];
        % Gather data for this pulse period
        [audio_data_piece, audio_index_info_piece, audio_filled_piece] = ...
            collect_sync_pulse_period_data(this_path, next_path, this_drop_info, next_drop_info, this_onset, next_onset, file_cache, audio_loader, audio_data_slicer, audio_data_sizer, audio_data_combiner, [], 'MaxCacheSize', 9);

        % Naneye file paths
        this_path = sync_struct_segment(idx).naneye_file;
        next_path = sync_struct_segment(idx+1).naneye_file;
        % Flash onsets
        this_onset = sync_struct_segment(idx).naneye_flash_onset;
        next_onset = sync_struct_segment(idx+1).naneye_flash_onset;
        % Drop info
        this_drop_info = sync_struct_segment(idx).naneye_drop_info;
        next_drop_info = sync_struct_segment(idx+1).naneye_drop_info;
        % Gather data for this pulse period
        [naneye_data_piece, naneye_index_info_piece, naneye_filled_piece] = ...
            collect_sync_pulse_period_data(this_path, next_path, this_drop_info, next_drop_info, this_onset, next_onset, file_cache, video_loader, video_data_slicer, video_data_sizer, video_data_combiner, @fillInDroppedVideoFrames, 'MaxCacheSize', 9);

        % Webcam file paths
        this_path = sync_struct_segment(idx).webcam_file;
        next_path = sync_struct_segment(idx+1).webcam_file;
        % Flash onsets
        this_onset = sync_struct_segment(idx).webcam_flash_onset;
        next_onset = sync_struct_segment(idx+1).webcam_flash_onset;
        % Drop info
        this_drop_info = [];
        next_drop_info = [];
        % Gather data for this pulse period
        [webcam_data_piece, webcam_index_info_piece, webcam_filled_piece] = ...
            collect_sync_pulse_period_data(this_path, next_path, this_drop_info, next_drop_info, this_onset, next_onset, file_cache, video_loader, video_data_slicer, video_data_sizer, video_data_combiner, [], 'MaxCacheSize', 9);

        % Combine this new pulse data with data from prior pulses, if any
        audio_data = audio_data_combiner(audio_data, audio_data_piece);
        naneye_data = video_data_combiner(naneye_data, naneye_data_piece);
        webcam_data = video_data_combiner(webcam_data, webcam_data_piece);

        % Combine this new index data with data from prior pulses, if any
        audio_index_info = [audio_index_info, audio_index_info_piece]; %#ok<*AGROW>
        naneye_index_info = [naneye_index_info, naneye_index_info_piece];
        webcam_index_info = [webcam_index_info, webcam_index_info_piece];

        audio_filled = [audio_filled, audio_filled_piece];
        naneye_filled = [naneye_filled, naneye_filled_piece];
        webcam_filled = [webcam_filled, webcam_filled_piece];
    end

    naneye_data = reorientNaneyeVideo(naneye_data);

    mean_audio_fs = mean([sync_struct_segment.audio_fs]);
    mean_naneye_fs = mean([sync_struct_segment.naneye_fs]);
    mean_webcam_fs = mean([sync_struct_segment.webcam_fs]);

    pulse_tag = sprintf('pulse%04d_', pulse_idx);

    [~, name, ext] = fileparts(sync_struct_segment(1).audio_file);
    audio_output_path = fullfile(aligned_folder, [pulse_tag, name, ext]);
    audiowrite(audio_output_path, audio_data, mean_audio_fs);
    if options.WriteSourceInfo; writeSourceInfo(audio_output_path, audio_index_info, audio_filled); end

    [~, name, ext] = fileparts(sync_struct_segment(1).naneye_file);
    naneye_output_path = fullfile(aligned_folder, [pulse_tag, name, ext]);
    saveVideoData(naneye_data, naneye_output_path, 'Motion JPEG AVI', mean_naneye_fs);
    if options.WriteSourceInfo; writeSourceInfo(naneye_output_path, naneye_index_info, naneye_filled); end

    [~, name, ext] = fileparts(sync_struct_segment(1).webcam_file);
    webcam_output_path = fullfile(aligned_folder, [pulse_tag, name, ext]);
    saveVideoData(webcam_data, webcam_output_path, 'Motion JPEG AVI', mean_webcam_fs);
    if options.WriteSourceInfo; writeSourceInfo(webcam_output_path, webcam_index_info, webcam_filled); end

end